/**
 * generated by Xtext 2.18.0.M3
 */
package org.omg.sysml.xtext.ui.outline;

import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.omg.kerml.xtext.ui.outline.KerMLOutlineTreeProvider;
import org.omg.sysml.lang.sysml.ConjugatedPortDefinition;
import org.omg.sysml.lang.sysml.ConjugatedPortTyping;
import org.omg.sysml.lang.sysml.Expression;
import org.omg.sysml.lang.sysml.Feature;
import org.omg.sysml.lang.sysml.OccurrenceUsage;
import org.omg.sysml.lang.sysml.PortionKind;
import org.omg.sysml.lang.sysml.RequirementConstraintKind;
import org.omg.sysml.lang.sysml.RequirementConstraintMembership;
import org.omg.sysml.lang.sysml.RequirementDefinition;
import org.omg.sysml.lang.sysml.RequirementUsage;
import org.omg.sysml.lang.sysml.StateDefinition;
import org.omg.sysml.lang.sysml.StateSubactionKind;
import org.omg.sysml.lang.sysml.StateSubactionMembership;
import org.omg.sysml.lang.sysml.StateUsage;
import org.omg.sysml.lang.sysml.SysMLPackage;
import org.omg.sysml.lang.sysml.TriggerInvocationExpression;
import org.omg.sysml.lang.sysml.TriggerKind;
import org.omg.sysml.lang.sysml.Type;
import org.omg.sysml.util.TypeUtil;

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
@SuppressWarnings("all")
public class SysMLOutlineTreeProvider extends KerMLOutlineTreeProvider {
  public String _text(final StateSubactionMembership membership) {
    String _prefixText = this.prefixText(membership);
    String _plus = (_prefixText + " ");
    StateSubactionKind _kind = membership.getKind();
    String _plus_1 = (_plus + _kind);
    String _plus_2 = (_plus_1 + " ");
    String _nameText = this.nameText(membership);
    return (_plus_2 + _nameText);
  }

  public String _text(final RequirementConstraintMembership membership) {
    String _prefixText = this.prefixText(membership);
    String _plus = (_prefixText + " ");
    RequirementConstraintKind _kind = membership.getKind();
    String _plus_1 = (_plus + _kind);
    String _plus_2 = (_plus_1 + " ");
    String _nameText = this.nameText(membership);
    return (_plus_2 + _nameText);
  }

  @Override
  public String typePrefixText(final Type type) {
    String _xblockexpression = null;
    {
      String text = super.typePrefixText(type);
      boolean _isIndividual = TypeUtil.isIndividual(type);
      if (_isIndividual) {
        String _text = text;
        text = (_text + " individual");
      }
      _xblockexpression = text;
    }
    return _xblockexpression;
  }

  @Override
  public String featurePrefixText(final Feature feature) {
    String _xblockexpression = null;
    {
      String text = super.featurePrefixText(feature);
      if ((feature instanceof OccurrenceUsage)) {
        boolean _isIndividual = ((OccurrenceUsage)feature).isIndividual();
        if (_isIndividual) {
          String _text = text;
          text = (_text + " individual");
        }
        PortionKind _portionKind = ((OccurrenceUsage)feature).getPortionKind();
        boolean _equals = Objects.equal(_portionKind, PortionKind.SNAPSHOT);
        if (_equals) {
          String _text_1 = text;
          text = (_text_1 + " snapshot");
        } else {
          PortionKind _portionKind_1 = ((OccurrenceUsage)feature).getPortionKind();
          boolean _equals_1 = Objects.equal(_portionKind_1, PortionKind.TIMESLICE);
          if (_equals_1) {
            String _text_2 = text;
            text = (_text_2 + " timeslice");
          }
        }
      }
      _xblockexpression = text;
    }
    return _xblockexpression;
  }

  public String _text(final StateUsage state) {
    String _xblockexpression = null;
    {
      String text = this.featurePrefixText(state);
      boolean _isParallel = state.isParallel();
      if (_isParallel) {
        String _text = text;
        text = (_text + " parallel");
      }
      String _featureIdText = this.featureIdText(state);
      _xblockexpression = (text + _featureIdText);
    }
    return _xblockexpression;
  }

  public String _text(final StateDefinition state) {
    String _xblockexpression = null;
    {
      String text = this.typePrefixText(state);
      boolean _isParallel = state.isParallel();
      if (_isParallel) {
        String _text = text;
        text = (_text + " parallel");
      }
      String _idText = this.idText(state);
      _xblockexpression = (text + _idText);
    }
    return _xblockexpression;
  }

  public String _text(final TriggerInvocationExpression expression) {
    String __text = this._text(((Expression) expression));
    String _plus = (__text + " ");
    TriggerKind _kind = expression.getKind();
    return (_plus + _kind);
  }

  public boolean _isLeaf(final RequirementDefinition requirementDef) {
    return (this._isLeaf(((Type) requirementDef)) && (requirementDef.getText() == null));
  }

  public void _createChildren(final IOutlineNode parentNode, final RequirementDefinition requirementDef) {
    EList<String> _text = requirementDef.getText();
    boolean _tripleNotEquals = (_text != null);
    if (_tripleNotEquals) {
      EAttribute _requirementDefinition_Text = SysMLPackage.eINSTANCE.getRequirementDefinition_Text();
      Image __image = this._image(requirementDef.getText());
      EList<String> _text_1 = requirementDef.getText();
      String _plus = ("text " + _text_1);
      this.createEStructuralFeatureNode(parentNode, requirementDef, _requirementDefinition_Text, __image, _plus, true);
    }
    super._createChildren(parentNode, requirementDef);
  }

  public boolean _isLeaf(final RequirementUsage requirement) {
    return (this._isLeaf(((Type) requirement)) && (requirement.getText() == null));
  }

  public void _createChildren(final IOutlineNode parentNode, final RequirementUsage requirement) {
    EList<String> _text = requirement.getText();
    boolean _tripleNotEquals = (_text != null);
    if (_tripleNotEquals) {
      EAttribute _requirementDefinition_Text = SysMLPackage.eINSTANCE.getRequirementDefinition_Text();
      Image __image = this._image(requirement.getText());
      EList<String> _text_1 = requirement.getText();
      String _plus = ("text " + _text_1);
      this.createEStructuralFeatureNode(parentNode, requirement, _requirementDefinition_Text, __image, _plus, true);
    }
    super._createChildren(parentNode, requirement);
  }

  public boolean _isLeaf(final ConjugatedPortTyping typing) {
    ConjugatedPortDefinition _conjugatedPortDefinition = typing.getConjugatedPortDefinition();
    return (_conjugatedPortDefinition == null);
  }

  public void _createChildren(final IOutlineNode parentNode, final ConjugatedPortTyping typing) {
    ConjugatedPortDefinition _conjugatedPortDefinition = typing.getConjugatedPortDefinition();
    boolean _tripleNotEquals = (_conjugatedPortDefinition != null);
    if (_tripleNotEquals) {
      this.createEObjectNode(parentNode, typing.getConjugatedPortDefinition(), 
        this._image(typing.getConjugatedPortDefinition()), this._text(typing.getConjugatedPortDefinition()), false);
    }
  }
}
